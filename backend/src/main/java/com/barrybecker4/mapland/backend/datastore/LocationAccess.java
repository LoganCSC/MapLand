package com.barrybecker4.mapland.backend.datastore;

import com.barrybecker4.mapland.backend.datamodel.LocationAndUserBean;
import com.barrybecker4.mapland.backend.datamodel.UserBean;
import com.google.api.services.datastore.DatastoreV1;
import com.google.api.services.datastore.DatastoreV1.Entity;
import com.google.api.services.datastore.DatastoreV1.Key;
import com.google.api.services.datastore.DatastoreV1.Property;
import com.google.api.services.datastore.DatastoreV1.Value;
import com.google.api.services.datastore.client.DatastoreException;
import com.barrybecker4.mapland.backend.datamodel.LocationBean;
//import com.google.appengine.api.datastore.GeoPt;
//import com.google.appengine.api.datastore.Entity;

//import com.google.appengine.api.datastore.Query;
import com.google.api.services.datastore.DatastoreV1.Query;
import com.google.protobuf.ByteString;
//import com.google.appengine.api.datastore.Entity;
import static com.google.api.services.datastore.client.DatastoreHelper.*;

import java.util.LinkedList;
import java.util.List;
import java.util.Random;

/**
 * Based on the introductory code at https://cloud.google.com/datastore/docs/getstarted/start_java/
 * TODO: add a method that gets location for a specified lat/long
 */
public class LocationAccess extends DataStoreAccess {

    public static final String KIND = "Location";
    private static final Random RND = new Random();

    /**
     * Get the specified location if it is in the database.
     * If they are not in the database, throw an error.
     * @param locationId user id
     */
    public LocationBean getLocationById(Long locationId) {
        LocationBean location = null;

        try {
            Entity entity = getEntity(KIND, locationId);
            location = new LocationBean(entity);

        } catch (DatastoreException exception) {
            // Catch all Datastore rpc errors.
            System.err.println("Error while doing location datastore operation");
            // Log the exception, the name of the method called and the error code.
            System.err.println(String.format("DatastoreException(%s): %s %s",
                    exception.getMessage(),
                    exception.getMethodName(),
                    exception.getCode()));
            System.exit(1);
        }

        return location;
    }

    /**
     * Add a new location with the specified bounds and owning user.
     * Other info is generated as need.
     * The user also needs to be updated as part of the transaction to add the new location.
     */
    public LocationBean addNewLocation(String owner, Double nwLat, Double nwLong, Double seLat, Double seLong)
            throws DatastoreException {

        // The ID will be generated by the datastore
        Key.Builder key = Key.newBuilder().addPathElement(
                Key.PathElement.newBuilder().setKind(KIND)); //.setId(id));

        // Random cost and income assigned
        Long cost = 100L + RND.nextInt(200);
        Integer income = RND.nextInt(50);

        Entity locationEntity = createLocationEntity(key, owner, cost, income,
                nwLat, nwLong, seLat, seLong);

        addLocationWithOwner(locationEntity, owner);
        return new LocationBean(locationEntity);
    }

    /**
     * Transferring ownership of a location involves 3 things:
     * 1) The user needs to have this location added to its list of locations
     * 2) The location needs to have its owner property set to user
     * 3) The old owner needs to have this location removed from its list.
     * All these things need to happen as part of a single atomic transaction, and right now they are not.
     * In order to work as a single transaction, we may need to change the datamodel to have
     * users parents of locations. In that case, changing ownership will probably involve
     * deleting the location owned by the previous owner before recreating it for the new owner.
     * @param locationAndUser contains the location to update, and the new owner
     * @return the updated location (with new owner) and user (with new location).
     *   The old owner is updated too, but not returned.
     */
    public LocationAndUserBean transferLocationOwnership(
            LocationAndUserBean locationAndUser) throws DatastoreException {

        UserAccess userAccess = new UserAccess();
        LocationBean location = locationAndUser.getLocation();
        UserBean oldOwner = userAccess.getUserById(location.getOwnerId());
        UserBean newOwner = locationAndUser.getUser();

        if (newOwner.getLocations().contains(location.getId())) {
            throw new IllegalStateException(newOwner.getUserId() + " already owns location " + location.getId());
        }
        newOwner.getLocations().add(location.getId());
        location.setOwnerId(newOwner.getUserId());
        boolean removed = oldOwner.getLocations().remove(location.getId());
        if (!removed) {
            String msg = "Was not able to remove location " + location.getId() + " from " + oldOwner.getUserId();
           throw new IllegalStateException(msg);
        }

        // this should happen as part of a single transaction (but its not right now)
        userAccess.updateUser(oldOwner);
        userAccess.updateUser(newOwner);
        this.updateLocation(location);

        return locationAndUser;
    }


    public boolean updateLocation(LocationBean location) throws DatastoreException {

        // Set the transaction, so we get a consistent snapshot of the entity at the time the txn started.
        ByteString tx = createTransaction();

        // Create an RPC request to commit the transaction.
        DatastoreV1.CommitRequest.Builder creq = DatastoreV1.CommitRequest.newBuilder();
        // Set the transaction to commit.
        creq.setTransaction(tx);

        Entity entity = createLocationEntity(location);
        // Insert the entity in the commit request mutation.
        creq.getMutationBuilder().addUpdate(entity);

        // Execute the Commit RPC synchronously and ignore the response.
        // Apply the insert mutation if the entity was not found and close
        // the transaction.
        datastore.commit(creq.build());
        return true;
    }

    /**
     * These steps should all be part of one atomic transaction. The way it is now, there is
     * a microscopic chance that some other user could try to take ownership of the new location
     * before it gets added to the owner passed to this method.
     * In order to do that, we may have to switch the datamodel so that users are parents of locations.
     * One thing to note with that approach is that you cannot just change the ownership of a location.
     * It would need to be cloned, deleted, then added to the new user owner.
     * @param locationEntity new location to add
     * @param owner user that will initially own this new location.
     * @throws DatastoreException
     */
    private void addLocationWithOwner(Entity locationEntity, String owner) throws DatastoreException {
        UserAccess userAcces = new UserAccess();
        UserBean ownerBean = userAcces.getUserById(owner);

        locationEntity = insertEntity(locationEntity);

        Long locId = locationEntity.getKey().getPathElement(0).getId();
        ownerBean.getLocations().add(locId);

        boolean success = userAcces.updateUser(ownerBean);
        if (success) {
            System.out.println(owner + " just had location " + locId + " added.");
        }
        else {
            System.out.printf("Failed to add " + locId + " to " + owner);
        }
    }

    /**
     * Specify upper left and lower right corners of a bounding region.
     * Because of a limitation of GAE datastore, we cannot make inequality queries on more
     * than one property at a time. To workaround this, the query uses only a latitude
     * filter, then does further filtering on the results.
     * When GeoPt is supported bette, we can switch to using that.
     * @return a list of all locations within the bounds specified.
     */
    public List<LocationBean> getAllLocationsInViewPort(
            Double nwLat, Double nwLong, Double seLat, Double seLong) {

        // first query by latitude
        Query.Builder query = Query.newBuilder();

        // One degree of lattitude = about 69 miles, so 0.01 degrees is less than a mile.
        //final double APPX_WIDTH = 0.01;
        DatastoreV1.Filter nwLatFilter =
                makeFilter("nwLatitude", DatastoreV1.PropertyFilter.Operator.GREATER_THAN_OR_EQUAL, makeValue(nwLat))
                .build();
        // I really want this to be selattitude, but cannot query on more than one attribute
        // Switch to using GeoPt when feasable.
        DatastoreV1.Filter seLatFilter =
                makeFilter("nwLatitude", DatastoreV1.PropertyFilter.Operator.LESS_THAN_OR_EQUAL, makeValue(seLat))
                .build();

        query.setFilter(makeFilter(nwLatFilter, seLatFilter));
        query.addKindBuilder().setName(KIND);

        DatastoreV1.RunQueryRequest request = DatastoreV1.RunQueryRequest.newBuilder().setQuery(query).build();
        DatastoreV1.RunQueryResponse response;
        List<LocationBean> list = new LinkedList<>();

        try {
            response = datastore.runQuery(request);

            for (DatastoreV1.EntityResult result : response.getBatch().getEntityResultList()) {
                Entity locationEntity = result.getEntity();
                LocationBean locationBean = new LocationBean(locationEntity);
                System.out.println("retrieved " + locationBean);
                // only add it to the list if it also meets the longitude filter.
                // This must be done manually be because of bigTable query limitations.
                if (locationBean.getNwLongitudeCoord() >= nwLong &&
                        locationBean.getSeLongitudeCoord() <= seLong) {
                    list.add(locationBean);
                }
            }
        }
        catch (  DatastoreException e) {
            e.printStackTrace();
        }
        System.out.println("returning " + list.size() + " locations");

        return list;
    }

    /**
     * Specify upper left and lower right corners of a bounding region.
     * Because of a limitation of GAE datastore, we cannot make inequality queries on more
     * than one property at a time. To workaround this, the query uses only a latitude
     * filter, then does further filtering on the results.
     * When GeoPt is supported bette, we can switch to using that.
     * @return a list of all locations within the bounds specified.
     *
    public List<LocationBean> getAllLocationsInViewPort(
            Double nwLat, Double nwLong, Double seLat, Double seLong) {

        // first query by latitude
        Query.FilterPredicate nwLatFilter =
                new Query.FilterPredicate("nwLatitude",
                        Query.FilterOperator.GREATER_THAN_OR_EQUAL,
                        nwLat);

        Query.FilterPredicate seLatFilter =
                new Query.FilterPredicate("seLatitude",
                        Query.FilterOperator.LESS_THAN_OR_EQUAL,
                        seLat);

        // Use CompositeFilter to combine multiple filters
        Query.CompositeFilter latRangeFilter =
                Query.CompositeFilterOperator.and(nwLatFilter, seLatFilter);


        // Use class Query to assemble a query
        Query query = new Query("Location").setFilter(latRangeFilter);

        // Use PreparedQuery interface to retrieve results
        DatastoreService datastoreSvc = DatastoreServiceFactory.getDatastoreService();
        PreparedQuery pq = datastoreSvc.prepare(query);

        List<LocationBean> list = new ArrayList<>();

        for (Entity result : pq.asIterable()) { //pq.asIterable()) {
            LocationBean loc = new LocationBean(result);
            //String firstName = (String) result.getProperty("firstName");
            //String lastName = (String) result.getProperty("lastName");
            //Long height = (Long) result.getProperty("height");

            System.out.println(loc);
            list.add(loc);
        }

        // then manually filter by longitude (this is really only going to work as
        // long as there are less than 1000 items in the result
        return list;
    }*/

    private Entity createLocationEntity(LocationBean location) {

        // Set the entity key with only one `path_element`: no parent.
        Key.Builder key = Key.newBuilder().addPathElement(
                Key.PathElement.newBuilder().setKind(KIND).setId(location.getId()));

        return createLocationEntity(key, location.getOwnerId(), location.getCost(), location.getIncome(),
                location.getNwLatitudeCoord(), location.getNwLongitudeCoord(),
                location.getSeLatitudeCoord(), location.getSeLatitudeCoord());
    }

    /** @return new Location entity with specified info */
    private Entity createLocationEntity(
            Key.Builder key,  String ownerId, Long cost, Integer income,
            Double nwLat, Double nwLong, Double seLat, Double seLong) {
        Entity entity;
        Entity.Builder entityBuilder = Entity.newBuilder();
        // Set the entity key.
        entityBuilder.setKey(key);
        // - a 64 bit integer: `location id`
        entityBuilder.addProperty(Property.newBuilder()
                .setName("locationId")
                .setValue(Value.newBuilder())); //.setIntegerValue(locationId)));

        // - a utf-8 string: `user name`
        entityBuilder.addProperty(Property.newBuilder()
                .setName("ownerId")
                .setValue(Value.newBuilder().setStringValue(ownerId)));

        // - a 64bit integer: `cost`
        entityBuilder.addProperty(Property.newBuilder()
                .setName("cost")
                .setValue(Value.newBuilder().setIntegerValue(cost)));

        // - a 64bit integer: `income`
        entityBuilder.addProperty(Property.newBuilder()
                .setName("income")
                .setValue(Value.newBuilder().setIntegerValue(income)));


        // location region bounds
        entityBuilder.addProperty(Property.newBuilder()
                .setName("nwLatitude")
                .setValue(Value.newBuilder().setDoubleValue(nwLat)));
        entityBuilder.addProperty(Property.newBuilder()
                .setName("nwLongitude")
                .setValue(Value.newBuilder().setDoubleValue(nwLong)));
        entityBuilder.addProperty(Property.newBuilder()
                .setName("seLatitude")
                .setValue(Value.newBuilder().setDoubleValue(seLat)));
        entityBuilder.addProperty(Property.newBuilder()
                .setName("seLongitude")
                .setValue(Value.newBuilder().setDoubleValue(seLong)));

        // Build the entity.
        entity = entityBuilder.build();
        return entity;
    }
}
